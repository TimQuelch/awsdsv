#!/usr/bin/env bash

set -euo pipefail

help() {
    echo "Usage: awsdsv [-h|--help] [-j|--filter arg] [-f|--fields args...] [-a|--add args...] [ -q|--query ] [-s|--squash]"
    echo "-h,--help            Display this help"
    echo "-j,--filter arg      Override the jq filter used"
    echo "-f,--fields args...  Select the fields to display. Specify with no args to clear the default config"
    echo "-a,--add args...     Select additional fields to the default fields"
    echo "-q,--query           Display resolved configuration"
    echo "-s,--squash          Squash JSON result"
}

if ! PARSED=$(getopt -o "-hj:f::a:qs" --long help,filter:,fields::,add:,query,squash -n "awsdsv" -- "$@"); then
    help
    exit 1
fi

eval set -- "$PARSED"

fields=()
additional_fields=()

fields_arg_set=0
query_arg_set=0

while true; do
    case "$1" in
    -h | --help)
        help
        exit
        ;;
    -j | --filter)
        shift
        filter="$1"
        shift
        ;;
    -f | --fields)
        fields_arg_set=1
        shift
        while [[ $# -gt 0 && "$1" != -* ]]; do
            if [[ -n "$1" ]]; then
                fields+=("$1")
            fi
            shift
        done
        ;;
    -a | --add)
        shift
        while [[ $# -gt 0 && "$1" != -* ]]; do
            if [[ -n "$1" ]]; then
                additional_fields+=("$1")
            fi
            shift
        done
        ;;
    -q | --query)
        query_arg_set=1
        shift
        ;;
    -s | --squash)
        squash_arg_set=1
        shift
        ;;
    --)
        shift
        break
        ;;
    *)
        echo "invalid args: $*"
        exit
        ;;
    esac
done

get_leading_key() {
    jq -r 'keys[0]' "$1"
}

lookup_config_key() {
    jq -r --arg KEY "$1" "$2" <<<"$3"
}

lookup_get_filter() {
    lookup_config_key "$1" '.[$KEY]?.filter // empty' "$2"
}

lookup_get_fields() {
    lookup_config_key "$1" '.[$KEY]?.fields?.[]? // empty' "$2"
}

filter_fields() {
    if [[ $# -ne 0 ]]; then
        dsv --pretty cut "$@"
    else
        dsv --pretty
    fi
}

TMP_FILES=()

cleanup() {
    for f in "${TMP_FILES[@]}"; do
        rm -f "$f"
    done
}

trap cleanup EXIT

initial_response=$(mktemp)
TMP_FILES+=("$initial_response")
cat >"$initial_response"

key=$(get_leading_key "$initial_response")

SCRIPT_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
config=$(yq -r '.' "${AWSDSV_CONFIG_FILE:-$SCRIPT_DIR/config.yaml}")

if [[ ! -v filter || -z "$filter" ]]; then
    filter=$(lookup_get_filter "$key" "$config")
fi

if [[ ! -v filter || -z "$filter" ]]; then
    filter="map(arrays | .[])[]"
fi

if [[ "$fields_arg_set" == 0 ]]; then
    readarray -t fields < <(lookup_get_fields "$key" "$config")
fi

all_fields=("${fields[@]}" "${additional_fields[@]}")

base_filter='walk(if . == "" or . == [] then empty else . end) | . + (.Tags // [] | map({("tag:" + .Key): .Value}) | add) | del(.Tags)'

if [[ "$query_arg_set" == 0 ]]; then
    jq "$filter" "$initial_response" |
        jq "$base_filter" |
        dsv fromjson --slurp ${squash_arg_set:+--flatten} |
        filter_fields "${all_fields[@]}"
else
    filtered_response="$(jq "$filter" "$initial_response" | jq "$base_filter")"
    array_or_empty() { jq -R 'if . == "" then empty else . end' | jq -s; }
    jq -n \
        --arg filter "$filter" \
        --argjson top_level_keys \
        "$(jq "keys" "$initial_response")" \
        --argjson configured_fields \
        "$(printf "%s\n" "${fields[@]}" | array_or_empty)" \
        --argjson additional_fields \
        "$(printf "%s\n" "${additional_fields[@]}" | array_or_empty)" \
        --argjson available_fields \
        "$(<<<"$filtered_response" jq -rs 'map(keys) | flatten | unique')" \
        --argjson available_squashed_fields \
        "$(<<<"$filtered_response" jq -rs 'map(paths | join(".")) | unique')" \
        '$ARGS.named'
fi
